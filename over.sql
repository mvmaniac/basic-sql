-- OVER 절
-- COUNT, SUM, MIN, MAX와 같은 분석 함수와 집계 함수에 동시에 존재하는 함수는 OVER 절에 있으면 분석함수 그렇지 않으면 집계함수 임
-- 분석함수의 분석 대상을 정하는 역할을 함
-- 대부분의 분석함수는 OVER절과 같이 사용
-- OVER()와 같이 괄호 안에 아무런 옵션을 주지 않으면 조회된 결과 전체가 분석 대상임

-- OVER절 이해하기
-- 조회된 주문 건수를 마지막 컬럼에 추가하는 SQL, 에러발생
SELECT
	O.ORD_SEQ
	, O.CUS_ID
	, O.ORD_DT
	, COUNT(*) AS ALL_CNT
FROM T_ORD O
WHERE O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170302', 'YYYYMMDD')
;

-- 조회된 주문 건수를 마지막 컬럼에 추가하는 SQL, 분석함수 사용
-- 첫 번째 로우의 분석 대상은 분석함수를 사용하기 전의 조회된 결과가 분석 대상임
-- 마지막 로우의 분석 대상 역시 첫 번쨰 로우 분석 대상과 같음
-- OVER의 괄호 안에 별다른 옵션을 주지 않으면 조회가 완료된 결과 전체가 분석 대상임
SELECT
	O.ORD_SEQ
	, O.CUS_ID
	, O.ORD_DT
	, COUNT(*) OVER() AS ALL_CNT
FROM T_ORD O
WHERE O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170302', 'YYYYMMDD')
;

-- 분석 대상
-- GROUP BY가 없는 SQL
SELECT
	O.ORD_SEQ
	, O.CUS_ID
	, COUNT(*) OVER() AS ALL_CNT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170101', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170201', 'YYYYMMDD')
ORDER BY O.ORD_SEQ
;

-- GROUP BY가 있는 SQL
-- GROUP BY까지 처리된 결과가 분석 대상임
SELECT
	O.CUS_ID
	, COUNT(*) OVER() AS ALL_CNT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170101', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170201', 'YYYYMMDD')
GROUP BY O.CUS_ID
;

-- 분석함수와 GROUP BY 동시 사용
-- 안쪽의 SUM(O.ORD_AMT)는 CUS_ID 별로 주문금액을 집계한 집계함수고 바깥쪽의 SUM() OVER()는 분석함수 임
-- 분석함수는 집계함수가 처리된 SUM(O.ORD_AMT)에 대해서 분석을 수행
-- 분석함수와 GROUP BY가 동시에 사용될 때는 GROUP BY에 명시된 컬럼이나 SUM(O.ORD_AMT) 처럼 집계함수를 사용한 결과만 분석함수로 분석 할 수 있음
SELECT
	O.CUS_ID
	, SUM(SUM(O.ORD_AMT)) OVER() AS ALL_CNT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170101', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170201', 'YYYYMMDD')
GROUP BY O.CUS_ID
;

-- 분석함수와 집계함수의 차이
-- COUNT(*) AS BY_CUS_ORD_CNT: 고객별 주문건수, GROUP BY의 CUS_ID별 집계를 수행하는 집계함수
-- COUNT(*) OVER() AS ALL_CUST_CNT: 조회된 고객 수, 분석 대상의 데이터 건수를 세는 분석함수
-- SUM(COUNT(*)) OVER() AS BY_CUS_ORD_CNT
-- : 고객별 주문건수에 대한 합
-- : 안쪽의 COUNT(*)는 CUS_ID별 집계를 수행하는 집계함수
-- : 바깥쪽의 SUM() OVER()는 CUS_ID별 COUNT(*)에 대한 분석 함수
SELECT
	O.CUS_ID
 	, COUNT(*) AS BY_CUS_ORD_CNT
	, COUNT(*) OVER() AS ALL_CUST_CNT
	, SUM(COUNT(*)) OVER() AS ALL_ORD_CNT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170101', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170201', 'YYYYMMDD')
GROUP BY O.CUS_ID
;

-- OVER PARTITION BY
-- CUS_ID별로 PARTITION BY를 사용
-- 각 로우 별로 자신의 CUS_ID와 같은 CUS_ID를 가진 로우가 분석 대상임
-- PARTITION BY에 정의된 컬럼 값에 따라 칸막이를 만들어서 분석함
SELECT
	O.CUS_ID
	, TO_CHAR(O.ORD_DT, 'YYYYMM') AS ORD_YM
	, SUM(O.ORD_AMT) AS ORD_AMT
	, SUM(SUM(O.ORD_AMT)) OVER(PARTITION BY O.CUS_ID) AS BY_CUST_AMT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170601', 'YYYYMMDD')
GROUP BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
ORDER BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
;

-- 다양하게 PARTITION BY를 사용
-- OVER(PARTITION BY O.CUS_ID): 자신의 로우와 CUS_ID가 같은 로우들을 분석대상으로 지정
-- OVER(PARTITION BY O.ORD_ST): 자신의 로우와 ORD_ST가 같은 로우들을 분석대상으로 지정
-- OVER(PARTITION BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM'): 자신의 로우와 CUS_ID, 주문년월이 같은 로우들을 분석대상으로 지정
SELECT
	O.CUS_ID
	, TO_CHAR(O.ORD_DT, 'YYYYMM') AS ORD_YM
    , O.ORD_ST
	, SUM(O.ORD_AMT) AS ORD_AMT
	, SUM(SUM(O.ORD_AMT)) OVER(PARTITION BY O.CUS_ID) AS BY_CUST_AMT
	, SUM(SUM(O.ORD_AMT)) OVER(PARTITION BY O.ORD_ST) AS BY_ORD_ST_AMT
	, SUM(SUM(O.ORD_AMT)) OVER(PARTITION BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')) AS BY_CUST_YM_AMT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170601', 'YYYYMMDD')
GROUP BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM'), O.ORD_ST
ORDER BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM'), O.ORD_ST
;

-- ROLLUP과 PARTITION BY를 비교
-- ROLLUP
SELECT
	O.CUS_ID
	, TO_CHAR(O.ORD_DT, 'YYYYMM') AS ORD_YM
	, SUM(O.ORD_AMT) AS ORD_AMT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170601', 'YYYYMMDD')
GROUP BY ROLLUP(O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM'))
ORDER BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
;

-- PARTITION BY
SELECT
	O.CUS_ID
	, TO_CHAR(O.ORD_DT, 'YYYYMM') AS ORD_YM
	, SUM(O.ORD_AMT) AS ORD_AMT
	, SUM(SUM(O.ORD_AMT)) OVER(PARTITION BY O.CUS_ID) AS BY_CUST_AMT
	, SUM(SUM(O.ORD_AMT)) OVER() AS ALL_AMT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170601', 'YYYYMMDD')
GROUP BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
ORDER BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
;

-- 고객별로 주문금액 비율 구하기, PARTITION BY를 사용
SELECT
	O.CUS_ID
	, TO_CHAR(O.ORD_DT, 'YYYYMM') AS ORD_YM
	, SUM(O.ORD_AMT) AS ORD_AMT
	, ROUND(SUM(O.ORD_AMT) / (SUM(SUM(O.ORD_AMT)) OVER(PARTITION BY O.CUS_ID)) * 100.00, 2) AS ORD_AMT_RT_BY_CUST
	, ROUND(SUM(O.ORD_AMT) / (SUM(SUM(O.ORD_AMT)) OVER()) * 100.00, 2) AS ORD_AMT_RT_BY_ALL_AMT
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170601', 'YYYYMMDD')
GROUP BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
ORDER BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
;

-- OVER ORDER BY
-- 각 로우별로 ORDER BY에 따라 분석 대상이 다르게 정해짐
-- OVER 절 안에 ORDER BY가 있으면 ORDER BY 기준으로 자신보다 먼저 조회된 데이터가 분석대상이 됨
-- 특정 고객의 3월부터 8월까지의 6개월 간의 주문 조회, 월별 누적주문금액을 같이 표시
-- 누적주문금액
-- 3월 누적주문금액은 3월 주문금액과 동일
-- 4월 누적주문금액은 3월과 4월 주문금액 합계
-- 8월 누적주문금액은 3~8월의 주문금액 합계
SELECT
	TO_CHAR(O.ORD_DT, 'YYYYMM') AS ORD_YM
	, SUM(O.ORD_AMT) AS ORD_AMT
	, SUM(SUM(O.ORD_AMT)) OVER(ORDER BY TO_CHAR(O.ORD_DT, 'YYYYMM')) AS ORD_YM_SUM
FROM T_ORD O
WHERE O.CUS_ID = 'CUS_0002'
AND O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170901', 'YYYYMMDD')
GROUP BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
ORDER BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
;

-- ORDER BY, PARTITION BY와 동시 사용 가능
-- 분석대상을 PARTITION BY로 나눈 후 나누어진 단위별로 ORDER BY를 처리함
-- PARTITION BY가 ORDER BY보다 먼저 와야 함
-- PARTITION BY에 대상 컬럼을 콤마로 구분해서 적은 후 파티션의 마지막 컬럼과 ORDER BY 사이에 콤마를 사용하면 안됨
-- OVER(PARTITION BY O.CUS_ID, O.ORD_ST, O.PAY_TP ORDER BY O.ORD_AMT)
SELECT
    O.CUS_ID
	, TO_CHAR(O.ORD_DT, 'YYYYMM') AS ORD_YM
	, SUM(O.ORD_AMT) AS ORD_AMT
 	, SUM(SUM(O.ORD_AMT)) OVER(PARTITION BY O.CUS_ID) AS BY_CUST_AMT
	, SUM(SUM(O.ORD_AMT)) OVER(PARTITION BY O.CUS_ID ORDER BY TO_CHAR(O.ORD_DT, 'YYYYMM')) AS BY_CUS_ORD_YM_SUM
FROM T_ORD O
WHERE O.CUS_ID IN ('CUS_0002', 'CUS_0003')
AND O.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170601', 'YYYYMMDD')
GROUP BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')
ORDER BY O.CUS_ID, TO_CHAR(O.ORD_DT, 'YYYYMM')