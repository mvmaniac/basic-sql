-- 인덱스란
-- 테이블 내의 데이터를 찾을 수 있게 일부 데이터를 모아서 구성한 데이터 구조
-- 인덱스를 이용하면 테이블 내의 데이터를 빠르게 찾아낼수 있음

-- 테스트를 위한 테이블 만들기
CREATE TABLE T_ORD_BIG AS
SELECT
	O.*
	, T.RNO
	, TO_CHAR(O.ORD_DT, 'YYYYMMDD') AS ORD_YMD
FROM T_ORD O
, (
    SELECT ROWNUM AS RNO
	FROM DUAL CONNECT BY ROWNUM <= 10000
) T
;

-- 아래는 T_ORD_BIG 테이블의 통계를 생성하는 명령
-- 첫 번째 파라미터는 테이블 OWNER, 두 번쨰 파라미터는 테이블 명을 입력
-- DBMS_STATS의 실행 권한이 필요함
CALL DBMS_STATS.GATHER_TABLE_STATS('ORA_TEST_USER', 'T_ORD_BIG');

-- 인덱스가 없는 BIG 테이블 조회
/*
 ---------------------------------------------------------------------------------------------------
| Id  | Operation          | Name      | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
---------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |      1 |        |      1 |00:00:02.53 |     258K|    258K|
|   1 |  SORT AGGREGATE    |           |      1 |      1 |      1 |00:00:02.53 |     258K|    258K|
|*  2 |   TABLE ACCESS FULL| T_ORD_BIG |      1 |  10000 |  10000 |00:00:02.91 |     258K|    258K|
---------------------------------------------------------------------------------------------------
*/
SELECT /*+ GATHER_PLAN_STATISTICS */
   COUNT(*)
FROM T_ORD_BIG TOB
WHERE TOB.ORD_SEQ = 343
;

-- ORD_SEQ 컬럼에 인덱스 구성
CREATE INDEX X_T_ORD_BIG_TEST ON T_ORD_BIG(ORD_SEQ)
;

-- 인덱스 구성 후 조회
/*
 ---------------------------------------------------------------------------------------------------------
| Id  | Operation         | Name             | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
---------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |                  |      1 |        |      1 |00:00:00.01 |      24 |     23 |
|   1 |  SORT AGGREGATE   |                  |      1 |      1 |      1 |00:00:00.01 |      24 |     23 |
|*  2 |   INDEX RANGE SCAN| X_T_ORD_BIG_TEST |      1 |  10000 |  10000 |00:00:00.01 |      24 |     23 |
---------------------------------------------------------------------------------------------------------
*/
SELECT /*+ GATHER_PLAN_STATISTICS */
	COUNT(*)
FROM T_ORD_BIG TOB
WHERE TOB.ORD_SEQ = 343
;

-- 인덱스 종류
-- 컬럼 수에 따라
-- 1. 단일 인덱스: 인덱스에 하나의 컬럼만 사용
-- 2. 복합 인덱스: 인덱스에 2개 이상의 컬럼을 사용, 멀티 인덱스 또는 결합 인덱스라고도 함

-- 인덱스를 구성하는 컬럼 값들의 중복 허용 여부에 따라
-- 1. 유니크 인덱스: 인덱스 구성 컬럼들 값에 중복을 허용하지 않음
-- 2. 비유니크 인덱스: 인덱스 구성 컬럼들 값에 중복을 허용함

-- 물리적인 구조에 따라
-- 1. B* 트리 인덱스
-- 2. 비트맵 인덱스

-- 비트맵 인덱스
-- 값의 종류가 많지 않은 컬럼에 사용, 예를들어 주문유형에 대한 값이 '주문대기,주문완료' 두 종류 값만 있는 경우 사용
-- 하지만 파티션과 B*트리 인덱스를 사용하는 것이 성능면에서 유리할 때가 많음
-- 대용량 테이블에 파티션을 구성하는 게 좋은데, 파티션된 테이블에는 파티션 된 인덱스를 만들 수 있음
-- 1. 글로벌 인덱스
-- 2. 로컬 인덱스

-- B* 트리 인덱스
-- 루트블록
-- : 최상위에 단 하나만 존재
-- : 하위 브랜치 블록의 인덱스 키 값과 주소를 가짐
-- 브랜치 블록
-- : 루트와 리프 중간에 위치, 브랜치는 여러 층이 있을 수 있음
-- : 하위 브랜치의 인덱스 키 값과 주소 또는 하위 리프의 키 값과 주소를 가짐
-- 리프 블록
-- : 최하위에만 위치
-- : 인덱스 키 값과 데이터의 로우 위치(ROWID)를 가지고 있음
-- : 리프 블록은 인덱스 키 값 순으로 정렬됨

-- 데이터를 찾는 방법
-- 테이블 전체 읽기 (TABLE ACCESS FULL)
-- 인덱스를 이용한 찾기 (INDEX RANGE SCAN & TABLE ACCESS BY INDEX ROWID)
-- ROWID를 이용한 직접 찾기 (TABLE ACCESS BY INDEX ROWID)

-- 테이블 전체 읽기
/*
 ------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation          | Name      | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |      1 |        |      5 |00:00:03.26 |     258K|    258K|       |       |          |
|   1 |  SORT GROUP BY     |           |      1 |     90 |      5 |00:00:03.26 |     258K|    258K|  2048 |  2048 | 2048  (0)|
|*  2 |   TABLE ACCESS FULL| T_ORD_BIG |      1 |  87307 |  50000 |00:00:04.24 |     258K|    258K|       |       |          |
------------------------------------------------------------------------------------------------------------------------------
*/
SELECT /*+ GATHER_PLAN_STATISTICS */
	TOB.CUS_ID, COUNT(*) AS ORD_CNT
FROM T_ORD_BIG TOB
WHERE TOB.ORD_YMD = '20170316'
GROUP BY TOB.CUS_ID
ORDER BY TOB.CUS_ID
;

-- ORD_YMD 컬럼에 인덱스 구성
CREATE INDEX X_T_ORD_BIG_1 ON T_ORD_BIG(ORD_YMD)
;

-- INDEX RANGE SCAN을 이용하는 SQL
-- 총 3천만건에서 5만 건 정도를 찾은 경우라면 INDEX RANGE SCAN이 더 효율적임
/*
 ----------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                            | Name          | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
----------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |               |      1 |        |      5 |00:00:02.35 |   10313 |   9981 |       |       |          |
|   1 |  SORT GROUP BY                       |               |      1 |     90 |      5 |00:00:02.35 |   10313 |   9981 |  2048 |  2048 | 2048  (0)|
|   2 |   TABLE ACCESS BY INDEX ROWID BATCHED| T_ORD_BIG     |      1 |  87307 |  50000 |00:00:02.03 |   10313 |   9981 |       |       |          |
|*  3 |    INDEX RANGE SCAN                  | X_T_ORD_BIG_1 |      1 |  87307 |  50000 |00:00:00.05 |     142 |    141 |       |       |          |
----------------------------------------------------------------------------------------------------------------------------------------------------
*/
SELECT /*+ GATHER_PLAN_STATISTICS INDEX(TOB X_T_ORD_BIG_1) */
	TOB.CUS_ID, COUNT(*) AS ORD_CNT
FROM T_ORD_BIG TOB
WHERE TOB.ORD_YMD = '20170316'
GROUP BY TOB.CUS_ID
ORDER BY TOB.CUS_ID
;

-- 3개월간의 주문을 조회
-- ORD_YMD 컬럼 인덱스를 사용
-- 매우 많은 랜덤 액세스가 발생
/*
 ----------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                            | Name          | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
----------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |               |      1 |        |      2 |00:00:21.14 |    1026K|    157K|       |       |          |
|   1 |  HASH GROUP BY                       |               |      1 |      2 |      2 |00:00:21.14 |    1026K|    157K|  1186K|  1186K|  648K (0)|
|   2 |   TABLE ACCESS BY INDEX ROWID BATCHED| T_ORD_BIG     |      1 |   6354K|   7650K|00:00:17.28 |    1026K|    157K|       |       |          |
|*  3 |    INDEX RANGE SCAN                  | X_T_ORD_BIG_1 |      1 |   6354K|   7650K|00:00:01.27 |   21312 |  21311 |       |       |          |
----------------------------------------------------------------------------------------------------------------------------------------------------
*/
SELECT /*+ GATHER_PLAN_STATISTICS INDEX(TOB X_T_ORD_BIG_1) */
	TOB.ORD_ST, SUM(TOB.ORD_AMT)
FROM T_ORD_BIG TOB
WHERE TOB.ORD_YMD BETWEEN '20170401' AND '20170630'
GROUP BY TOB.ORD_ST
;

-- 테이블 전체 읽기 방식으로 변경
/*
------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation          | Name      | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |      1 |        |      2 |00:00:04.56 |     258K|    258K|       |       |          |
|   1 |  HASH GROUP BY     |           |      1 |      2 |      2 |00:00:04.56 |     258K|    258K|  1186K|  1186K|  648K (0)|
|*  2 |   TABLE ACCESS FULL| T_ORD_BIG |      1 |   6354K|   7650K|00:00:02.97 |     258K|    258K|       |       |          |
------------------------------------------------------------------------------------------------------------------------------
*/
SELECT /*+ GATHER_PLAN_STATISTICS FULL(TOB) */
	TOB.ORD_ST, SUM(TOB.ORD_AMT)
FROM T_ORD_BIG TOB
WHERE TOB.ORD_YMD BETWEEN '20170401' AND '20170630'
GROUP BY TOB.ORD_ST
;

-- 정리
-- 적은 양의 데이터를 읽는다면 INDEX RANGE SCAN 이 유리함
-- 많은 양의 데이터를 읽는다면 FULL SCAN 이 유리함
-- FULL SCAN 은 데이터가 쌓일수록 성능이 점차 나빠짐, 테이블 관리 전략이 필요

-- 실제 실행계획 조회하기
SELECT
	V$S.SQL_ID
	, V$S.CHILD_NUMBER
	, V$S.SQL_TEXT
FROM V$SQL V$S
WHERE V$S.SQL_TEXT LIKE '%GATHER_PLAN_STATISTICS%'
ORDER BY V$S.LAST_ACTIVE_TIME DESC
;

SELECT *
FROM TABLE (DBMS_XPLAN.DISPLAY_CURSOR('16vn9naf37yvs', 0, 'ALLSTATS LAST'))
;
