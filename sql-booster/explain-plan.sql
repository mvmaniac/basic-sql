-- 실행계획 만들기
EXPLAIN PLAN FOR
SELECT *
FROM T_ORD O
WHERE O.ORD_SEQ = 4
;

-- 실행계획 확인하기
-- Id: 실행계획의 오퍼레이션 ID
-- Operation: 해당 단계에 수행한 작업내용
-- Name: 해당 단계에서 작업을 수행한 대상 오브젝트(테이블 또는 인덱스)
-- Rows: 해당 단계 수행시 조회될 예상 데이터 건수
-- Bytes: 해당 단계까지 사용될 예상 데이터 양(누적)
-- Cost: 해당 단계까지 사용될 예상 비용(누적)
-- Time: 해당 단계까지 사용될 예상 시간(누적)
/*
 ----------------------------------------------------------------------------------------
| Id  | Operation                   | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |          |     1 |    44 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| T_ORD    |     1 |    44 |     2   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_T_ORD |     1 |       |     1   (0)| 00:00:01 |
----------------------------------------------------------------------------------------
*/
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY())
;

-- 실행계획 생성 및 조회
EXPLAIN PLAN FOR
SELECT *
FROM T_ORD O
	INNER JOIN M_CUS MC ON O.CUS_ID = MC.CUS_ID
WHERE O.ORD_DT >= TO_DATE('20170201', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170301', 'YYYYMMDD')
AND MC.CUS_GD = 'A'
;

-- 부모, 자식, 형제 관계를 정의
-- 1. 부모는 여러 자식을 가질 수 있으며, 자식은 부모보다 들여쓰기 되어 있음
-- : 아래 실행계획에서 오퍼레이션 1은 오퍼레이션 2와 3의 부모
-- 2. 형제는 같은 들여쓰기 수준을 하고 있음
-- : 아래 실행계획에서 오퍼레이션2와 3은 형제 관계
-- 3. 형제 중에는 위쪽의 오퍼레이션이 형임
-- : 아래 실행계획에서 2와 3중에 2가 형임

-- 기본 순서
-- 1. 자식이 부모보다 먼저 수행 됨
-- : 오퍼레이션 2와 3은 1의 자식으로 2와 3이 1보다 먼저 수행 됨
-- : 오퍼레이션 1은 오퍼레이션 0의 자식으로 1이 0보다 먼저 수행 됨
-- 2. 형제간에는 형이 먼저 수행 됨
-- : 오퍼레이션 2와 3은 형제로 2가 형이며 그러므로 2가 3보다 먼저 수행 됨
-- 3. 아래 실행계획의 순서는 2 -> 3 -> 1 -> 0 순서라고 할 수 있음
-- 4. 실행계획을 순서로 정의 할 필요는 없으며, 2번 오퍼레이션과 3번 오퍼레이션에 대해
--    해시 조인이 수행 되고 3보다 위에 있는 2번을 먼저 접근 했다 정도로 해석하면 충분함.
/*
----------------------------------------------------------------------------
| Id  | Operation          | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |       |   488 | 59536 |    10   (0)| 00:00:01 |
|*  1 |  HASH JOIN         |       |   488 | 59536 |    10   (0)| 00:00:01 |
|*  2 |   TABLE ACCESS FULL| M_CUS |    60 |  4680 |     3   (0)| 00:00:01 |
|*  3 |   TABLE ACCESS FULL| T_ORD |   244 | 10736 |     7   (0)| 00:00:01 |
----------------------------------------------------------------------------
*/
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY())
;

-- 좀 더 복잡한 실행계획 생성 및 조회
EXPLAIN PLAN FOR
SELECT
	MI.ITM_ID
	, SUM(TOD.ORD_QTY) AS ORD_QTY
FROM T_ORD O
	INNER JOIN T_ORD_DET TOD ON TOD.ORD_SEQ = O.ORD_SEQ
	INNER JOIN M_ITM MI ON MI.ITM_ID = TOD.ITM_ID
WHERE O.ORD_DT >= TO_DATE('20170201', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170301', 'YYYYMMDD')
AND MI.ITM_TP = 'ELEC'
GROUP BY MI.ITM_ID
;

-- 1. 4번 단계는 소트 조인
-- 2. 소트 조인 전에 8번과 9번 단계의 테이블을 해시 조인
-- 3. 4번 단계는 다시 1번의 머지 조인에 사용
-- 4. 1번의 머지 조인 대상은 2번과 4번 단계이고, 2번 단계를 먼저 접근
-- 5. 2번 단계는 3번의 'INDEX FULL SCAN' 단계를 포함
-- 실행계획을 보고 전체 순서를 완벽하게 파악 할 필요는 없음
-- 어느 오퍼레이션이 어느 오퍼레이션보다 먼저 수행되는지 정도만 파악해도 성능 개선을 할 수 있음
/*
 ------------------------------------------------------------------------------------------
| Id  | Operation                    | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |           |     8 |   384 |    16  (13)| 00:00:01 |
|   1 |  MERGE JOIN                  |           |     8 |   384 |    16  (13)| 00:00:01 |
|*  2 |   TABLE ACCESS BY INDEX ROWID| M_ITM     |    10 |   130 |     2   (0)| 00:00:01 |
|   3 |    INDEX FULL SCAN           | PK_M_ITM  |   100 |       |     1   (0)| 00:00:01 |
|*  4 |   SORT JOIN                  |           |    80 |  2800 |    14  (15)| 00:00:01 |
|   5 |    VIEW                      | VW_GBC_10 |    80 |  2800 |    13   (8)| 00:00:01 |
|   6 |     HASH GROUP BY            |           |    80 |  2080 |    13   (8)| 00:00:01 |
|*  7 |      HASH JOIN               |           |   303 |  7878 |    12   (0)| 00:00:01 |
|*  8 |       TABLE ACCESS FULL      | T_ORD     |   244 |  2928 |     7   (0)| 00:00:01 |
|   9 |       TABLE ACCESS FULL      | T_ORD_DET |  3224 | 45136 |     5   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
*/
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY())
;

-- 실제 실행계획 만들기
-- GATHER_PLAN_STATISTICS 힌트를 사용
-- GATHER_PLAN_STATISTICS 힌트를 추가해 SQL를 실행하면 DBMS_XPLAN.DISPLAY_CURSOR를 이용해 실행계획을 확인
-- DBMS_XPLAN.DISPLAY_CURSOR를 이용하려면 특정 뷰에 SELECT 권한이 필요 (V_$SQL, V_$SQL_PLAN_STATISTICS_ALL, V_$SQL_PLAN, V_$SESSION)
SELECT /*+ GATHER_PLAN_STATISTICS */ *
FROM T_ORD O
	INNER JOIN M_CUS MC ON O.CUS_ID = MC.CUS_ID
WHERE O.ORD_DT >= TO_DATE('20170201', 'YYYYMMDD')
AND O.ORD_DT < TO_DATE('20170301', 'YYYYMMDD')
AND MC.CUS_GD = 'A'
;

-- 실제 실행계획을 만든 SQL의 SQL ID 찾아내기
SELECT
	V$S.SQL_ID
	, V$S.CHILD_NUMBER
	, V$S.SQL_TEXT
FROM V$SQL V$S
WHERE V$S.SQL_TEXT LIKE '%GATHER_PLAN_STATISTICS%'
ORDER BY V$S.LAST_ACTIVE_TIME DESC
;

-- 실제 실행계획
-- Id: 실행계획의 오퍼레이션 ID
-- Operation: 해당 단계에 수행한 작업내용
-- Starts: 해당 단계를 수행한 횟수
-- E-Rows: 해당 단계의 예상 데이터 건수
-- A-Rows: 해당 단계의 실제 데이터 건수
-- A-Time: 해당 단계까지 수행된 실제 시간(누적), 복잡한 실행계획이나 병렬쿼리에서는 부정확하게 나오는 경우도 있음
-- Buffers: 해당 단계까지 메모리 버퍼에서 읽은 블록 수(논리적 IO 횟수, 누적)
-- Reads: 해당 단계까지 디스크에서 읽은 블록 수(물리적 IO 횟수, 누적)
-- 0Mem, 1Mem, Used-Mem: SQL 처리를 위해 사용한 메모리 수치

-- 주의 깊게 볼 항목은 'A-Rows, A-Time, Buffers' 로
-- 해당 항목이 눈에 띄게 수치가 높아진 단계가 있다면 해당 부분의 원인을 찾아 성능개선을 하면 됨
/*
--------------------------------------------------------------------------------------------------------------------------
| Id  | Operation          | Name  | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
--------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |       |      1 |        |    128 |00:00:00.01 |      69 |      5 |       |       |          |
|*  1 |  HASH JOIN         |       |      1 |    488 |    128 |00:00:00.01 |      69 |      5 |   908K|   908K| 1318K (0)|
|*  2 |   TABLE ACCESS FULL| M_CUS |      1 |     60 |     60 |00:00:00.01 |       7 |      0 |       |       |          |
|*  3 |   TABLE ACCESS FULL| T_ORD |      1 |    244 |    198 |00:00:00.01 |      24 |      0 |       |       |          |
--------------------------------------------------------------------------------------------------------------------------
*/
SELECT *
FROM TABLE (DBMS_XPLAN.DISPLAY_CURSOR('f4d2xkxw0z9v6', 0, 'ALLSTATS LAST'))
;

-- 비용기반 옵티마이져
-- 비용은 IO 횟수, CPU Time, 메모리 사용량을 의미
-- 비용을 산출할 때 가장 중요한 것은 테이블의 통계 정보

-- 소프트 파싱, 하드 파싱
-- SQL를 실행하면 가장 먼저 구문분석 후 통과하면 SQL의 실행계획이 메모리에 있는지 검색
-- 만들어 놓은 실행계획이 메모리에 있으면 재사용 하는데 이것을 소프트 파싱
-- 만들어 놓은 실행계획이 메모리에 없으면 옵티마이져가 실행계획을 새로 만드는데 구문분석과 함께 실행계획까지 만드는 과정을 하드 파싱
-- 예시
-- 1. 주문 테이블에는 총 백만건이 있는데 A 고객은 한건, B 고객은 십만건의 주문이 있음
-- 2. A 고객의 주문 검색은 '고객 ID 인덱스'를 사용하는 것이 성능에 유리
-- 3. B 고객의 주문 검색은 '고객 ID 인덱스'를 사용하면 성능에 좋지 않음
--    (찾으려는 데이터가 많으면, 인덱스를 이용한 검색은 비효율적일 수 있음)
-- 4. A 고객 주문을 먼저 조회, '고객 ID 인덱스'를 사용하는 실행계획인 만들어짐 (A 고객의 결과는 빠르게 처리)
-- 5. B 고객 주믄을 조회, 방금 만든 '고객 ID 인덱스' 실행계획을 재사용 (B 고객의 결과는 오래 걸릴 수 있음)

-- 논리적 IO와 물리적 IO
-- 오라클에는 버퍼캐시라는 메모리 영역이 있음, 버퍼캐시에서 필요한 데이터를 가져오는 과정을 논리적 IO라고 함
-- 버퍼캐시에 원하는 데이터가 없으면, 디스크까지 가서 데이터블록을 가져와야 하는데 이것이 바로 물리적 IO 임
-- 처음 SQL를 실행하면 느리지만, 같은 SQL를 두 번째 실행하면 빠르게 결과가 나오는 것은
-- 처음 실행했을 때는 물리적 IO가 포함되어 있고, 두 번째 실행부터는 버퍼캐시를 이용하는 논리적 IO로만 처리되기 때문
-- 성능 향상을 위해 충분한 메모리가 필요한 것은 사실이나, 메모리를 늘려 버퍼캐시를 크게 설정한다고 데이터베이스 성능이 선형적으로 좋아지는 것 아님
-- 최소한의 IO로 SQL 처리 될 수 있도록 적절한 인덱스 전략과 함께 적절한 SQL이 선행 되어야 함